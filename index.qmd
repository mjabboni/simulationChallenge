---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.


```{python}
#| echo: false
#| include: false
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

# Create figure and axis with better sizing
fig, ax = plt.subplots(figsize=(10, 6))
# Adjust axis limits to ensure all elements fit with padding
ax.set_xlim(-2.5, 8.5)
ax.set_ylim(-0.3, 4.3)
ax.axis('off')

# Define node positions
w0_pos = (4, 2.5)
ct_pos = (0, 1)
wt_pos = (4, 1)

# Draw nodes with ovals (ellipses)
w0_box = mpatches.Ellipse(w0_pos, 2.4, 0.8,
                          facecolor='aliceblue', edgecolor='black', linewidth=2)
ct_box = mpatches.Ellipse(ct_pos, 2.4, 0.8,
                          facecolor='aliceblue', edgecolor='black', linewidth=2)
wt_box = mpatches.Ellipse(wt_pos, 2.4, 1.0,
                          facecolor='aliceblue', edgecolor='black', linewidth=2)

# Add boxes to plot first
ax.add_patch(w0_box)
ax.add_patch(ct_box)
ax.add_patch(wt_box)

# Calculate edge positions for connections (ellipse edges)
# w0 ellipse: bottom edge at y = center_y - height/2 = 2.5 - 0.4 = 2.1
# wt ellipse: top edge at y = center_y + height/2 = 1 + 0.5 = 1.5
w0_bottom = (w0_pos[0], w0_pos[1] - 0.4)
wt_top = (wt_pos[0], wt_pos[1] + 0.5)

# ct ellipse: right edge at x = center_x + width/2 = 0 + 1.2 = 1.2
# wt ellipse: left edge at x = center_x - width/2 = 4 - 1.2 = 2.8
ct_right = (ct_pos[0] + 1.2, ct_pos[1])
wt_left = (wt_pos[0] - 1.2, wt_pos[1])

# Draw edges connecting to box edges (after boxes so arrows render on top)
ax.annotate('', xy=wt_top, xytext=w0_bottom, 
            arrowprops=dict(arrowstyle='->', lw=2, color='black'))
ax.annotate('', xy=wt_left, xytext=ct_right, 
            arrowprops=dict(arrowstyle='->', lw=2, color='black'))

# Add text labels
ax.text(w0_pos[0], w0_pos[1], 'Initial Wealth\n$W_0 = 30,000$', 
        ha='center', va='center', fontsize=11, weight='bold')
ax.text(ct_pos[0], ct_pos[1], 'Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$', 
        ha='center', va='center', fontsize=11, weight='bold')
ax.text(wt_pos[0], wt_pos[1], 'Wealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$', 
        ha='center', va='center', fontsize=11, weight='bold')

# Add plate (rectangle around time-dependent nodes)
plate = mpatches.FancyBboxPatch((-2, 0.5), 7.8, 1.0,
                                 boxstyle="round,pad=0.2", 
                                 facecolor='none', edgecolor='black', linewidth=1.5, linestyle='--')
ax.add_patch(plate)
# Position text at the bottom below coin flip oval and inside the plate
# Coin flip oval bottom is at y = 1 - 0.4 = 0.6, plate bottom is at y = 0.5
# Place text at y = 0.35 (moved 1 line higher from 0.30)
ax.text(ct_pos[0], 0.35, 't = 1, ..., N', fontsize=10, weight='bold', 
        ha='center', va='bottom')

# Ensure proper spacing and fit
plt.tight_layout(pad=1.0)

# Store the figure for later display
investmentDAG_fig = fig

```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

After one coin flip, the expected value of your account balance is **greater than $30,000**. 

Here's the calculation: With a fair coin (50% probability each outcome), after one flip you will either:
- Win heads: $30,000 Ã— 1.5 = $45,000 (with probability 0.5)
- Lose tails: $30,000 Ã— 0.6 = $18,000 (with probability 0.5)

The expected value is: 0.5 Ã— $45,000 + 0.5 Ã— $18,000 = $31,500

This represents a gain of $1,500, which is **5% of your $30,000 buy-in**.

However, this simple expected value analysis alone may not be sufficient to make a buy-in decision. While the positive expected value suggests the game is favorable in the long run, there are several important considerations:
- **Volatility**: The outcomes are highly variable (you could lose 40% in a single flip)
- **Time horizon**: This analysis only considers one flip, but the game continues annually until age 75
- **Compound effects**: Over many periods, even a positive expected value per flip can lead to substantial losses due to the asymmetric compounding (gains multiply by 1.5, losses multiply by 0.6)
- **Risk tolerance**: The 40% loss scenario might be unacceptable depending on your risk tolerance

The positive expected value after one flip suggests a favorable bet *in expectation*, but we need to examine the full distribution of outcomes over the entire game duration to make an informed decision.

```{python}
#| label: q1-expected-value-py
#| echo: false

# Calculate expected value after one flip
buy_in = 30000
prob_heads = 0.5
prob_tails = 0.5

# Outcomes after one flip
value_heads = buy_in * 1.5  # Increase by 50%
value_tails = buy_in * 0.6  # Decrease by 40%

# Expected value calculation
expected_value = prob_heads * value_heads + prob_tails * value_tails
gain = expected_value - buy_in
gain_percentage = (gain / buy_in) * 100

print(f"Initial buy-in: ${buy_in:,.2f}")
print(f"Value if heads (Ã—1.5): ${value_heads:,.2f}")
print(f"Value if tails (Ã—0.6): ${value_tails:,.2f}")
print(f"\nExpected value after one flip: ${expected_value:,.2f}")
print(f"Gain in expected value: ${gain:,.2f}")
print(f"Gain as percentage of buy-in: {gain_percentage:.2f}%")
print(f"\nComparison: EV {expected_value:,.2f} {'>' if expected_value > buy_in else '<' if expected_value < buy_in else '='} ${buy_in:,.2f}")
```

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance over 10 years (ages 65-75)"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Simulation parameters
buy_in = 30000
num_years = 10  # Playing from age 65 to age 75
prob_heads = 0.5

# Initialize tracking arrays
years = np.arange(0, num_years + 1)
balance = np.zeros(num_years + 1)
balance[0] = buy_in

# Simulate coin flips
coin_flips = np.random.binomial(1, prob_heads, num_years)

# Calculate balance over time
for year in range(1, num_years + 1):
    if coin_flips[year - 1] == 1:  # Heads: increase by 50%
        balance[year] = balance[year - 1] * 1.5
    else:  # Tails: decrease by 40%
        balance[year] = balance[year - 1] * 0.6

# Create time series plot using matplotlib OO interface
fig, ax = plt.subplots(figsize=(8, 5))
ax.plot(years, balance, linewidth=2, color='#2E86AB', label='Account Balance')
ax.axhline(y=buy_in, color='#A23B72', linestyle='--', linewidth=1.5, label=f'Initial Buy-in (${buy_in:,})')
ax.set_xlabel('Year', fontsize=12, fontweight='bold')
ax.set_ylabel('Account Balance ($)', fontsize=12, fontweight='bold')
ax.set_title('Investment Simulation: Account Balance Over 10 Years', fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle=':', linewidth=0.8)
ax.legend(loc='best', framealpha=0.9)
ax.set_xlim(0, num_years)

# Format y-axis to show currency
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Add text annotation for final balance
final_balance = balance[-1]
ax.text(num_years * 0.98, final_balance, f'Final: ${final_balance:,.0f}', 
        ha='right', va='bottom', fontsize=10, bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.7))

plt.tight_layout()
plt.show()

# Print summary statistics
print(f"\n{'='*60}")
print("SIMULATION SUMMARY")
print(f"{'='*60}")
print(f"Starting age: 65 years")
print(f"Ending age: 75 years")
print(f"Number of coin flips: {num_years}")
print(f"Initial balance: ${buy_in:,.2f}")
print(f"Final balance: ${final_balance:,.2f}")
print(f"Net gain/loss: ${final_balance - buy_in:,.2f}")
print(f"Return percentage: {((final_balance - buy_in) / buy_in) * 100:.2f}%")
print(f"\nCoin flip sequence (H=Heads, T=Tails):")
flip_sequence = ''.join(['H' if flip == 1 else 'T' for flip in coin_flips])
print(f"{flip_sequence[:50]}..." if len(flip_sequence) > 50 else flip_sequence)
print(f"\nHeads count: {np.sum(coin_flips)} ({np.sum(coin_flips)/num_years*100:.1f}%)")
print(f"Tails count: {num_years - np.sum(coin_flips)} ({(num_years - np.sum(coin_flips))/num_years*100:.1f}%)")
print(f"{'='*60}\n")
```

**Narrative:**

This single simulation run demonstrates the volatile nature of the investment game. Starting with a $30,000 buy-in, the account balance fluctuates dramatically over the 10-year period. Each year, a coin flip determines the fate: heads multiplies the balance by 1.5 (50% gain), while tails multiplies it by 0.6 (40% loss).

The time series plot reveals the asymmetric compounding effect: while gains and losses have equal probability, their magnitudes differ. A sequence of tails creates steep declines that are difficult to recover from, while strings of heads generate exponential growth. The path shown in this simulation illustrates one possible trajectory through the investment landscape.

**Assessment of this outcome:**

Whether I'm "happy" with this particular outcome depends entirely on the final balance achieved. If the simulation results in a final balance above $30,000, there's a positive nominal return. However, even a positive outcome may be concerning because:

1. **Extreme volatility**: The journey likely included significant drawdowns and periods where the balance fell well below the initial investment
2. **Psychological stress**: Large swings could create anxiety and make it difficult to maintain the investment strategy
3. **Opportunity cost**: The capital was tied up in a highly volatile investment for 10 years with no guarantees
4. **Inflation**: Even if nominally positive, the real purchasing power may have eroded over 10 years

**Why this matters:**

This single simulation serves as a cautionary tale. While the expected value per flip is positive (5% gain per flip), any single realization can end dramatically differently. The extreme volatility means that luck plays a crucial role, and the path dependency of compounding ensures that early losses are particularly damaging. Before committing $30,000, we need to examine the full distribution of outcomes across many simulations to understand the true risk profile of this investment.

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

```{python}
#| label: q3-dist-main-py
#| echo: false
#| fig-cap: "Distribution of final balances showing probability of happy outcomes (>$30,000)"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Simulation parameters
buy_in = 30000
num_years = 10  # Playing from age 65 to age 75
num_simulations = 100
prob_heads = 0.5

# Storage for final balances
final_balances = np.zeros(num_simulations)

# Run 100 simulations
for sim in range(num_simulations):
    balance = buy_in
    
    # Simulate coin flips for each year
    coin_flips = np.random.binomial(1, prob_heads, num_years)
    
    # Calculate balance over time
    for year in range(num_years):
        if coin_flips[year] == 1:  # Heads: increase by 50%
            balance = balance * 1.5
        else:  # Tails: decrease by 40%
            balance = balance * 0.6
    
    final_balances[sim] = balance

# Calculate statistics
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
prob_above_buyin = np.mean(final_balances > buy_in)
prob_happy = prob_above_buyin  # Probability of being happy (final > $30,000)

# Create single histogram visualization
happy_count = np.sum(final_balances > buy_in)
unhappy_count = np.sum(final_balances <= buy_in)

# Group outcomes > 100,000 by capping them for display
group_threshold = 100000
final_balances_display = np.copy(final_balances)
values_above_threshold = final_balances > group_threshold
count_above_threshold = np.sum(values_above_threshold)
final_balances_display[values_above_threshold] = group_threshold

fig, ax = plt.subplots(figsize=(8, 5))

# Create bins up to 100,000, then add one final bin for grouped values > 100,000
min_balance = final_balances.min()
bins_normal = np.linspace(min_balance, group_threshold, 30)
bins = np.append(bins_normal, group_threshold + (group_threshold - min_balance) / 30)  # Add one more bin for grouped values

# Histogram with clear distinction between happy and unhappy outcomes
unhappy_values = final_balances_display[final_balances <= buy_in]
happy_values = final_balances_display[final_balances > buy_in]

ax.hist(unhappy_values, bins=bins, alpha=0.7, 
         color='#E63946', label=f'Unhappy Outcomes (â‰¤${buy_in:,})', 
         edgecolor='black', linewidth=0.8)
ax.hist(happy_values, bins=bins, alpha=0.7, 
         color='#06A77D', label=f'Happy Outcomes (>${buy_in:,})', 
         edgecolor='black', linewidth=0.8)

ax.axvline(x=buy_in, color='#A23B72', linestyle='--', linewidth=3, 
            label=f'Buy-in Threshold (${buy_in:,})', zorder=10)
# Add vertical line showing grouping threshold for values > 100,000
if count_above_threshold > 0:
    ax.axvline(x=group_threshold, color='#FFD700', linestyle=':', linewidth=2, 
                alpha=0.7, zorder=5)
ax.axvline(x=mean_balance, color='#F18F01', linestyle='--', linewidth=2, 
            label=f'Mean (${mean_balance:,.0f})', zorder=10)
ax.axvline(x=median_balance, color='#FFB627', linestyle='--', linewidth=2, 
            label=f'Median (${median_balance:,.0f})', zorder=10)
ax.set_xlabel('Final Account Balance ($) [Values > $100,000 grouped]', fontsize=12, fontweight='bold')
ax.set_ylabel('Number of Simulations', fontsize=12, fontweight='bold')
ax.set_title('Distribution of Final Balances After 100 Simulations', 
              fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle=':', linewidth=0.8)
ax.legend(loc='lower right', framealpha=0.9, fontsize=9)
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))
# Set x-axis limits to include the grouped bin
ax.set_xlim(left=min_balance, right=group_threshold + (group_threshold - min_balance) / 30)

# Add annotation showing grouped values > 100,000 (after setting axis limits)
if count_above_threshold > 0:
    y_max = ax.get_ylim()[1]
    ax.text(group_threshold, y_max * 0.9, 
          f'{count_above_threshold} outcomes\n> ${group_threshold:,}\ngrouped here', 
             ha='center', va='bottom', fontsize=9, 
             bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.7))

# Add probability annotation
ax.text(0.75, 0.85, 
         f'Happy Outcomes: {happy_count}/{num_simulations} ({prob_happy*100:.1f}%)\n'
         f'Unhappy Outcomes: {unhappy_count}/{num_simulations} ({(1-prob_happy)*100:.1f}%)\n'
         f'P(Balance > ${buy_in:,}) = {prob_happy:.3f}',
         transform=ax.transAxes, ha='center', va='top', fontsize=10, fontweight='bold',
         bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.9))

plt.tight_layout()
plt.show()

# Print summary
print(f"\n{'='*70}")
print("DISTRIBUTION SUMMARY: Probability of Happy Outcomes")
print(f"{'='*70}")
print(f"Initial buy-in: ${buy_in:,}")
print(f"Number of simulations: {num_simulations}")
print(f"\nOutcome Classification:")
print(f"  Happy outcomes (Balance > ${buy_in:,}): {happy_count} simulations")
print(f"  Unhappy outcomes (Balance â‰¤ ${buy_in:,}): {unhappy_count} simulations")
if count_above_threshold > 0:
    print(f"\nNote: {count_above_threshold} simulation(s) had final balances > ${group_threshold:,}")
    print(f"      These are grouped at ${group_threshold:,} in the histogram for visualization.")
print(f"\nProbability Analysis:")
print(f"  P(Happy outcome) = {prob_happy:.3f} ({prob_happy*100:.1f}%)")
print(f"  P(Unhappy outcome) = {1-prob_happy:.3f} ({(1-prob_happy)*100:.1f}%)")
print(f"\nInterpretation:")
print(f"  After investing ${buy_in:,}, there is a {prob_happy*100:.1f}% chance")
print(f"  of ending with more than your initial investment.")
print(f"{'='*70}\n")

```

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Comprehensive distribution analysis of final balances across 100 simulations"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Simulation parameters
buy_in = 30000
num_years = 10  # Playing from age 65 to age 75
num_simulations = 100
prob_heads = 0.5

# Storage for final balances
final_balances = np.zeros(num_simulations)

# Run 100 simulations
for sim in range(num_simulations):
    balance = buy_in
    
    # Simulate coin flips for each year
    coin_flips = np.random.binomial(1, prob_heads, num_years)
    
    # Calculate balance over time
    for year in range(num_years):
        if coin_flips[year] == 1:  # Heads: increase by 50%
            balance = balance * 1.5
        else:  # Tails: decrease by 40%
            balance = balance * 0.6
    
    final_balances[sim] = balance

# Calculate statistics
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
prob_above_buyin = np.mean(final_balances > buy_in)
prob_happy = prob_above_buyin  # Probability of being happy (final > $30,000)

# Create single histogram visualization (log scale)
fig, ax = plt.subplots(figsize=(8, 5))

bins = np.logspace(np.log10(final_balances.min()), np.log10(final_balances.max()), 50)
n, bins_edges, patches = ax.hist(final_balances, bins=bins, alpha=0.7, color='#2E86AB', 
                                   edgecolor='black', linewidth=0.5)

# Color bars based on whether they're above or below buy-in
for i, (patch, left_edge, right_edge) in enumerate(zip(patches, bins_edges[:-1], bins_edges[1:])):
    if right_edge <= buy_in:
        patch.set_facecolor('#E63946')  # Red for below buy-in
    else:
        patch.set_facecolor('#06A77D')  # Green for above buy-in

ax.axvline(x=buy_in, color='#A23B72', linestyle='--', linewidth=2.5, 
            label=f'Initial Buy-in (${buy_in:,})', zorder=10)
ax.axvline(x=mean_balance, color='#F18F01', linestyle='--', linewidth=2, 
            label=f'Mean (${mean_balance:,.0f})', zorder=10)
ax.axvline(x=median_balance, color='#FFB627', linestyle='--', linewidth=2, 
            label=f'Median (${median_balance:,.0f})', zorder=10)
ax.set_xscale('log')
ax.set_xlabel('Final Account Balance ($, log scale)', fontsize=12, fontweight='bold')
ax.set_ylabel('Frequency', fontsize=12, fontweight='bold')
ax.set_title('Distribution of Final Balances After 100 Simulations', fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle=':', linewidth=0.8)
ax.legend(loc='upper left', framealpha=0.9, fontsize=9)
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Add probability annotation
ax.text(0.98, 0.98, f'P(Balance > ${buy_in:,}) = {prob_above_buyin:.3f}\n({prob_above_buyin*100:.1f}%)', 
         transform=ax.transAxes, ha='right', va='top', fontsize=10, fontweight='bold',
         bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

plt.tight_layout()
plt.show()

# Print summary statistics
print(f"\n{'='*70}")
print("SIMULATION RESULTS: 100 RUNS")
print(f"{'='*70}")
print(f"Initial buy-in: ${buy_in:,}")
print(f"Number of simulations: {num_simulations}")
print(f"Number of years per simulation: {num_years}")
print(f"\nFinal Balance Statistics:")
print(f"  Mean:   ${mean_balance:,.2f}")
print(f"  Median: ${median_balance:,.2f}")
print(f"  Minimum: ${final_balances.min():,.2f}")
print(f"  Maximum: ${final_balances.max():,.2f}")
print(f"  Standard Deviation: ${np.std(final_balances):,.2f}")
print(f"\nProbability of Final Balance > ${buy_in:,}: {prob_above_buyin:.3f} ({prob_above_buyin*100:.1f}%)")
print(f"Probability of Final Balance â‰¤ ${buy_in:,}: {1-prob_above_buyin:.3f} ({(1-prob_above_buyin)*100:.1f}%)")
print(f"\nInterpretation:")
print(f"  Out of {num_simulations} simulations, {np.sum(final_balances > buy_in)} ended above ${buy_in:,}")
print(f"  Out of {num_simulations} simulations, {np.sum(final_balances <= buy_in)} ended at or below ${buy_in:,}")
print(f"{'='*70}\n")

```

**Narrative Description of the Distribution:**

The histogram reveals a highly skewed distribution of final account balances after 100 simulations. This distribution tells a compelling and concerning story about the investment game's risk profile.

**Distribution Characteristics:**

The distribution is strongly right-skewed with a long tail extending to very high values. Most simulations result in relatively modest final balances, while a small number of "lucky" simulations achieve extraordinary wealth. This asymmetry is visible in the histogram where:

- **Mean vs. Median**: The mean final balance is substantially higher than the median, indicating the distribution is pulled upward by extreme outliers. While the mean might suggest a favorable average outcome, the median provides a more realistic picture of what a typical investor can expect.

- **Wide Range**: The distribution spans several orders of magnitude, from near-zero balances (complete or near-complete losses) to millions of dollars. This extreme variability reflects the compound nature of the game where sequences of heads or tails create exponentially different outcomes.

- **Majority Below Buy-in**: A critical finding is that a significant portion of simulations end below the initial $30,000 investment. This means that despite the positive expected value per flip (calculated in Section 1), the compound effect over 10 years creates many paths where the final balance is less than the original buy-in.

**Probability of "Happy" Outcomes:**

Defining a "happy" outcome as one where the final balance exceeds the initial $30,000 investment, the simulation computes this probability directly (shown in the output above). This probability quantifies the likelihood of achieving at least a nominal positive return on the investmentâ€”essentially, the chance that after 10 years of playing the game (from age 65 to 75), you'll end up with more than your original $30,000 buy-in.

**What This Means for Decision-Making:**

1. **Risk of Loss**: The complement of the "happy" outcome probability represents the chance that the final balance is at or below $30,000â€”a substantial probability that indicates a meaningful risk of losing money or breaking even over 10 years. Even after adjusting for inflation, breaking even represents a real loss of purchasing power over such a long time horizon.

2. **Mean is Misleading**: While the mean might suggest a favorable investment, it's heavily influenced by rare but extreme positive outcomes. The median provides a more realistic expectation for most investors.

3. **Gambler's Ruin Effect**: The asymmetric compounding (50% gain vs. 40% loss) creates a mathematical structure where strings of losses are more damaging than equivalent strings of gains are beneficial. This is because 0.6 Ã— 0.6 Ã— 0.6 = 0.216 (losing 78.4% after 3 tails) is much worse than 1.5 Ã— 1.5 Ã— 1.5 = 3.375 (gaining 237.5% after 3 heads) is beneficial, relative to recovering from losses.

4. **Path Dependency**: Early losses are particularly devastating because they reduce the base amount that can grow from future wins. This path dependency means that the order of coin flips matters tremendously, not just the final count of heads and tails.

**Conclusion:**

The distribution analysis reveals that this investment game, despite having a positive expected value per flip, carries substantial risk of long-term losses due to compound effects over 10 years. The high variance and right-skewed distribution mean that while some investors might achieve exceptional returns, most will experience outcomes ranging from modest gains to significant losses. The probability of "happy" outcomes (final balance > $30,000) must be weighed against the substantial probability of negative or break-even results, especially when considering inflation and opportunity costs over the 10-year horizon.

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

```{python}
#| label: q4-prob-original-py
#| echo: false
#| fig-cap: "Probability estimate that final balance exceeds $30,000 after 10 years of the original game"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility (same as section 3 for consistency)
np.random.seed(42)

# Simulation parameters
buy_in = 30000
num_years = 10  # Playing from age 65 to age 75
num_simulations = 100
prob_heads = 0.5

# Storage for final balances
final_balances = np.zeros(num_simulations)

# Run 100 simulations
for sim in range(num_simulations):
    balance = buy_in
    
    # Simulate coin flips for each year
    coin_flips = np.random.binomial(1, prob_heads, num_years)
    
    # Calculate balance over time
    for year in range(num_years):
        if coin_flips[year] == 1:  # Heads: increase by 50%
            balance = balance * 1.5
        else:  # Tails: decrease by 40%
            balance = balance * 0.6
    
    final_balances[sim] = balance

# Calculate probability estimate
prob_above_buyin = np.mean(final_balances > buy_in)
prob_below_buyin = 1 - prob_above_buyin

# Count outcomes
count_above = np.sum(final_balances > buy_in)
count_below = np.sum(final_balances <= buy_in)

# Create single bar chart visualization
categories = ['Balance > $30,000', 'Balance â‰¤ $30,000']
counts = [count_above, count_below]
probabilities = [prob_above_buyin, prob_below_buyin]
colors = ['#06A77D', '#E63946']

fig, ax = plt.subplots(figsize=(8, 5))

bars = ax.bar(categories, counts, color=colors, alpha=0.7, edgecolor='black', linewidth=1.5, width=0.6)
ax.set_ylabel('Number of Simulations', fontsize=12, fontweight='bold')
ax.set_title('Probability That Final Balance > $30,000 at Age 75 (Original Game)', 
             fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle=':', linewidth=0.8, axis='y')
ax.set_ylim(0, num_simulations)

# Add count labels on bars
for bar, count, prob in zip(bars, counts, probabilities):
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2., height + 1,
             f'{count}\n({prob*100:.1f}%)',
             ha='center', va='bottom', fontsize=12, fontweight='bold')

# Add probability annotation
ax.text(0.5, 0.95, 
         f'P(Balance > $30,000) = {prob_above_buyin:.3f}',
         transform=ax.transAxes, ha='center', va='top', 
         fontsize=14, fontweight='bold',
         bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.9, edgecolor='black', linewidth=2))

plt.tight_layout()
plt.show()

# Report the probability estimate with 3 decimals
print(f"{'='*70}")
print("PROBABILITY ESTIMATE: P(Final Balance > $30,000)")
print(f"{'='*70}")
print(f"Number of simulations: {num_simulations}")
print(f"Number of years: {num_years} (ages 65-75)")
print(f"\nProbability estimate: P(Final > ${buy_in:,}) = {prob_above_buyin:.3f}")
print(f"As percentage: {prob_above_buyin*100:.1f}%")
print(f"\nNumber of simulations ending above ${buy_in:,}: {count_above}")
print(f"Number of simulations ending at or below ${buy_in:,}: {count_below}")
print(f"{'='*70}\n")

# Additional statistics for context
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
print(f"Context Statistics:")
print(f"  Mean final balance: ${mean_balance:,.2f}")
print(f"  Median final balance: ${median_balance:,.2f}")
print(f"  Standard deviation: ${np.std(final_balances):,.2f}\n")
```

**Probability Estimate:** Based on 100 simulations of the investment game played annually from age 65 to age 75 (10 years), the probability that the final account balance exceeds the initial $30,000 buy-in is reported above with three decimal precision.

**Practical Interpretation:**

This probability estimate reveals critical insights for the buy-in decision:

1. **Risk Assessment**: The probability estimate quantifies the chance that after 10 years of playing this game, you'll end up with $30,000 or lessâ€”effectively breaking even or losing money. This represents a substantial risk, especially when considering inflation and opportunity costs over a decade-long investment horizon. The complement of this probability (1 minus the reported value) represents the likelihood of an unfavorable outcome that must be carefully considered.

2. **Decision Framework**: While a probability above 0.5 (50%) would suggest the game is favorable in terms of ending above the buy-in, any probability below 1.0 means there's a meaningful chance of a negative or break-even outcome. The specific value reported above provides the exact quantitative measure needed to assess whether this level of risk is acceptable for a $30,000 investment decision.

3. **Long-Term Financial Planning**: For someone making a $30,000 investment decision, understanding what proportion of simulated outcomes resulted in balances at or below the initial investment provides crucial context. This isn't just a theoretical riskâ€”it's a quantifiable probability based on the game's mechanics that directly informs financial planning decisions.

4. **Volatility vs. Expected Value**: Despite the positive expected value per flip calculated in Section 1 (5% gain per flip), the compound effects over 10 years create scenarios where the final balance falls below the buy-in. This highlights the difference between short-term expected value and long-term compound risk, demonstrating why expected value alone is insufficient for decision-making. The probability estimate above quantifies this compound risk explicitly.

5. **Comparison to Alternatives**: In practical terms, the probability of not exceeding your initial investment over 10 years (the complement of the reported probability) is a critical metric for comparison. Traditional investment alternatives (such as diversified portfolios) typically offer different risk-return profiles, and this probability helps quantify the specific risk profile of this investment game, enabling informed comparisons with other investment options.

**Conclusion**: The probability estimate provides a quantitative foundation for the buy-in decision. Combined with the distribution analysis from Section 3, this probability enables an informed assessment of whether the potential upside justifies the risk of ending at or below the initial investment. A probability significantly below 1.0 indicates substantial risk that must be weighed against the potential for gains, while considering personal risk tolerance and alternative investment opportunities.

### 5) Modified Strategy (Bet 25% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

**Modified Strategy Mechanics:**

When only 25% of the balance is gambled:
- **Heads (win)**: 75% remains safe + 25% gains 50% â†’ Balance = Balance Ã— (0.75 + 0.25 Ã— 1.5) = Balance Ã— 1.125 (12.5% gain)
- **Tails (lose)**: 75% remains safe + 25% loses 40% â†’ Balance = Balance Ã— (0.75 + 0.25 Ã— 0.6) = Balance Ã— 0.9 (10% loss)

This is much more conservative than the original strategy where:
- **Heads**: Balance Ã— 1.5 (50% gain)
- **Tails**: Balance Ã— 0.6 (40% loss)

```{python}
#| label: q5-modified-25pct-py
#| echo: false
#| fig-cap: "Comparison of original vs modified (25% bet) strategy distributions"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Simulation parameters
buy_in = 30000
num_years = 10  # Playing from age 65 to age 75
num_simulations = 100
prob_heads = 0.5

# Storage for final balances - both strategies
final_balances_original = np.zeros(num_simulations)
final_balances_modified = np.zeros(num_simulations)

# Run 100 simulations for BOTH strategies (same coin flips for fair comparison)
for sim in range(num_simulations):
    # Original strategy
    balance_original = buy_in
    # Modified strategy
    balance_modified = buy_in
    
    # Same coin flips for fair comparison
    coin_flips = np.random.binomial(1, prob_heads, num_years)
    
    # Calculate balance over time for both strategies
    for year in range(num_years):
        # Original strategy: gamble 100% of balance
        if coin_flips[year] == 1:  # Heads: increase by 50%
            balance_original = balance_original * 1.5
        else:  # Tails: decrease by 40%
            balance_original = balance_original * 0.6
        
        # Modified strategy: gamble 25% of balance
        if coin_flips[year] == 1:  # Heads: 75% safe + 25% gains 50%
            balance_modified = balance_modified * (0.75 + 0.25 * 1.5)  # = balance * 1.125
        else:  # Tails: 75% safe + 25% loses 40%
            balance_modified = balance_modified * (0.75 + 0.25 * 0.6)  # = balance * 0.9
    
    final_balances_original[sim] = balance_original
    final_balances_modified[sim] = balance_modified

# Calculate statistics for both strategies
mean_original = np.mean(final_balances_original)
median_original = np.median(final_balances_original)
std_original = np.std(final_balances_original)
prob_above_original = np.mean(final_balances_original > buy_in)

mean_modified = np.mean(final_balances_modified)
median_modified = np.median(final_balances_modified)
std_modified = np.std(final_balances_modified)
prob_above_modified = np.mean(final_balances_modified > buy_in)

# Create single comparison histogram visualization
fig, ax = plt.subplots(figsize=(8, 5))

bins_log = np.logspace(2, 8, 50)
ax.hist(final_balances_original, bins=bins_log, alpha=0.6, color='#E63946', 
         edgecolor='black', linewidth=0.5, label='Original (100% bet)')
ax.hist(final_balances_modified, bins=bins_log, alpha=0.6, color='#06A77D', 
         edgecolor='black', linewidth=0.5, label='Modified (25% bet)')
ax.axvline(x=buy_in, color='#A23B72', linestyle='--', linewidth=2.5, 
            label=f'Buy-in (${buy_in:,})', zorder=10)
ax.set_xscale('log')
ax.set_xlabel('Final Account Balance ($, log scale)', fontsize=12, fontweight='bold')
ax.set_ylabel('Frequency', fontsize=12, fontweight='bold')
ax.set_title('Strategy Comparison: Original (100% bet) vs Modified (25% bet)', 
             fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle=':', linewidth=0.8)
ax.legend(loc='upper left', framealpha=0.9, fontsize=9)
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Add probability annotations
ax.text(0.98, 0.98, 
         f'Original P(> ${buy_in:,}) = {prob_above_original:.3f}\n'
         f'Modified P(> ${buy_in:,}) = {prob_above_modified:.3f}',
         transform=ax.transAxes, ha='right', va='top', fontsize=10, fontweight='bold',
         bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.9))

plt.tight_layout()
plt.show()

# Print detailed comparison
print(f"\n{'='*80}")
print("STRATEGY COMPARISON: Original (100% bet) vs Modified (25% bet)")
print(f"{'='*80}")
print(f"\nOriginal Strategy (100% of balance gambled):")
print(f"  Mean final balance:   ${mean_original:,.2f}")
print(f"  Median final balance: ${median_original:,.2f}")
print(f"  Standard deviation:   ${std_original:,.2f}")
print(f"  Minimum:              ${final_balances_original.min():,.2f}")
print(f"  Maximum:              ${final_balances_original.max():,.2f}")
print(f"  P(Balance > ${buy_in:,}):      {prob_above_original:.3f} ({prob_above_original*100:.1f}%)")

print(f"\nModified Strategy (25% of balance gambled):")
print(f"  Mean final balance:   ${mean_modified:,.2f}")
print(f"  Median final balance: ${median_modified:,.2f}")
print(f"  Standard deviation:   ${std_modified:,.2f}")
print(f"  Minimum:              ${final_balances_modified.min():,.2f}")
print(f"  Maximum:              ${final_balances_modified.max():,.2f}")
print(f"  P(Balance > ${buy_in:,}):      {prob_above_modified:.3f} ({prob_above_modified*100:.1f}%)")

print(f"\n{'='*80}")
print("KEY INSIGHTS:")
print(f"{'='*80}")
print(f"Risk Assessment (Lower Std Dev = Less Risky):")
if std_modified < std_original:
    print(f"  âœ“ Modified strategy is LESS RISKY (std dev: ${std_modified:,.2f} < ${std_original:,.2f})")
else:
    print(f"  âœ— Modified strategy is MORE RISKY (std dev: ${std_modified:,.2f} > ${std_original:,.2f})")

print(f"\nUpside Potential (Higher Max = Better Upside):")
if final_balances_modified.max() > final_balances_original.max():
    print(f"  âœ“ Modified strategy has BETTER UPSIDE (max: ${final_balances_modified.max():,.2f} > ${final_balances_original.max():,.2f})")
elif final_balances_original.max() > final_balances_modified.max():
    print(f"  âœ— Modified strategy has WORSE UPSIDE (max: ${final_balances_modified.max():,.2f} < ${final_balances_original.max():,.2f})")
else:
    print(f"  = Both strategies have similar upside")

print(f"\nSafety (Probability of ending above buy-in):")
if prob_above_modified > prob_above_original:
    print(f"  âœ“ Modified strategy is SAFER ({prob_above_modified*100:.1f}% > {prob_above_original*100:.1f}%)")
else:
    print(f"  âœ— Modified strategy is LESS SAFE ({prob_above_modified*100:.1f}% < {prob_above_original*100:.1f}%)")

print(f"\nAverage Outcome (Mean balance):")
if mean_modified > mean_original:
    print(f"  âœ“ Modified strategy has HIGHER MEAN (${mean_modified:,.2f} > ${mean_original:,.2f})")
else:
    print(f"  âœ— Modified strategy has LOWER MEAN (${mean_modified:,.2f} < ${mean_original:,.2f})")

print(f"\nTypical Outcome (Median balance):")
if median_modified > median_original:
    print(f"  âœ“ Modified strategy has HIGHER MEDIAN (${median_modified:,.2f} > ${median_original:,.2f})")
else:
    print(f"  âœ— Modified strategy has LOWER MEDIAN (${median_modified:,.2f} < ${median_original:,.2f})")
print(f"{'='*80}\n")
```

**Comparison Analysis:**

**Which is Riskier?**

The **original strategy (100% bet)** is significantly riskier. This is evident from several metrics:

1. **Standard Deviation**: The original strategy has much higher volatility, with a standard deviation that is dramatically larger than the modified strategy. This means outcomes vary much more widely around the mean.

2. **Downside Risk**: The minimum final balance is typically much lower in the original strategy. When you gamble the entire balance, a string of tails can devastate your account balance, pushing it toward near-zero values.

3. **Extreme Outcomes**: The original strategy produces both extreme losses and extreme gains, creating a much wider distribution of outcomes. The modified strategy, by protecting 75% of the balance each year, creates more stable, predictable outcomes.

**Which has Better Upside?**

The **original strategy (100% bet)** has better upside potential. When you gamble the full balance:

1. **Maximum Values**: The original strategy can achieve much higher maximum balances because the entire balance compounds at 1.5Ã— (50% gain) on each heads flip. In the modified strategy, only 25% of the balance gets the full 50% gain, while 75% remains unchanged, limiting the compounding effect.

2. **Exponential Growth**: The original strategy allows for true exponential growth when you get a sequence of heads. For example, after 5 consecutive heads:
   - Original: Balance Ã— (1.5)^5 = Balance Ã— 7.59 (759% gain)
   - Modified: Balance Ã— (1.125)^5 = Balance Ã— 1.802 (80% gain)

3. **Mean vs. Median**: The original strategy's mean is typically much higher, though this is heavily influenced by rare extreme outcomes. The median (typical outcome) may actually favor the modified strategy.

**Trade-off Summary:**

The comparison reveals a classic risk-return trade-off:

- **Original Strategy (100% bet)**: High risk, high potential reward. Offers the chance for extraordinary gains but also the risk of devastating losses. The distribution is highly skewed with a long right tail but also significant downside.

- **Modified Strategy (25% bet)**: Lower risk, lower but more consistent reward. Offers more predictable outcomes with less volatility, but caps the upside potential. The distribution is tighter and more centered around moderate gains.

**Practical Implications:**

For a $30,000 investment decision:
- If you can tolerate high volatility and are seeking maximum upside (understanding you might lose most of your investment), the **original strategy** might be acceptable.
- If you prefer stability, want to protect most of your capital, and are satisfied with moderate but more reliable returns, the **modified strategy** is the better choice.

The modified strategy essentially trades some upside potential for downside protectionâ€”a conservative approach that reduces both risk and reward.

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"

The Kelly Criterion is a mathematical formula that determines the optimal fraction of your bankroll to bet in order to maximize long-term logarithmic growth. Developed by John Kelly in 1956, it provides the theoretically optimal bet size when you have repeated opportunities to gamble with positive expected value.

**The Kelly Formula:**

For a bet where you win with probability $p$ and lose with probability $q = 1-p$, and where:
- A win multiplies your bet by $(1 + b)$ (gain of $b$)
- A loss multiplies your bet by $(1 - a)$ (loss of $a$)

The Kelly fraction $f^*$ that maximizes expected logarithmic growth is:

$$f^* = \frac{p \times a - q \times b}{a \times b}$$

When wins and losses are symmetric (i.e., $a = b$), this simplifies to:

$$f^* = \frac{p - q}{a}$$

**Applying Kelly to Our Investment Game:**

In our original game:
- Probability of heads (win): $p = 0.5$
- Probability of tails (loss): $q = 0.5$
- Win multiplier: $1.5$ (gain of $b = 0.5$ or 50%)
- Loss multiplier: $0.6$ (loss of $a = 0.4$ or 40%)

Using the general Kelly formula:
$$f^* = \frac{0.5 \times 0.4 - 0.5 \times 0.5}{0.4 \times 0.5} = \frac{0.2 - 0.25}{0.2} = \frac{-0.05}{0.2} = -0.25$$

**Critical Finding:** The Kelly fraction is **negative** ($-0.25$ or $-25\%$).

This negative Kelly fraction has profound implications:

1. **Mathematical Interpretation**: A negative Kelly fraction means that, despite having a positive expected value per flip (5% gain as calculated in Section 1), betting the full balance actually **reduces** long-term expected logarithmic growth. The asymmetric compounding (50% gain vs. 40% loss) creates a situation where the geometric mean growth is negative when you bet 100% of your balance.

2. **Why This Happens**: The Kelly Criterion is based on maximizing the **geometric mean** (logarithmic average) of returns, not the arithmetic mean. While the arithmetic mean return per flip is positive, the geometric mean can be negative when betting too aggressively. This occurs because:
   - After one flip: Geometric mean = $\sqrt{1.5 \times 0.6} = \sqrt{0.9} = 0.949$ (loss of 5.1%)
   - After many flips, betting 100% of your balance leads to expected geometric growth that compounds downward despite positive arithmetic expectation

3. **The Optimal Strategy**: The negative Kelly fraction suggests you should bet **less than zero** of your balanceâ€”which in practical terms means you should either:
   - Not play the game at all, or
   - Bet a fraction much smaller than 100%, potentially even taking the "other side" if that were possible

**Connection to the Modified Strategy (25% Bet):**

The modified strategy, which bets only 25% of the balance each round, can be analyzed through the Kelly lens:

When betting fraction $f = 0.25$ (25%):
- **Heads (win)**: Balance = Balance Ã— $(0.75 + 0.25 Ã— 1.5)$ = Balance Ã— $1.125$
- **Tails (loss)**: Balance = Balance Ã— $(0.75 + 0.25 Ã— 0.6)$ = Balance Ã— $0.9$

The geometric mean per flip becomes:
$$\sqrt{1.125 \times 0.9} = \sqrt{1.0125} = 1.0062$$

This represents a **positive geometric mean growth** of about 0.62% per flip, compared to the negative geometric growth when betting 100%.

**Interpreting Section 5's Findings Through Kelly:**

The comparison in Section 5 revealed that:

1. **Lower Risk with 25% Bet**: The reduced volatility (lower standard deviation) observed in the modified strategy aligns with Kelly's insight. By betting less than the full balance, you reduce the negative impact of the asymmetric compounding while still participating in the positive expected value.

2. **Better Probability of Positive Outcomes**: The higher probability of ending above the buy-in with the modified strategy reflects the fact that betting 25% creates positive geometric mean growth, whereas betting 100% creates negative geometric mean growth over time.

3. **The Upside Trade-off**: While the modified strategy reduces maximum potential gains (because you're not leveraging the full 50% gain on your entire balance), it preserves capital more effectively. From a Kelly perspective, this preservation is crucialâ€”the criterion prioritizes long-term survival and growth over short-term maximum returns.

**Practical Implications:**

The Kelly Criterion provides a mathematical foundation for understanding why the modified strategy performs better despite "sacrificing" upside:

- **Survival Principle**: Kelly emphasizes that avoiding ruin (preserving capital) is essential for long-term growth. The 25% bet strategy, while not necessarily the exact Kelly-optimal fraction for this game, follows the Kelly principle of preserving capital while still capturing positive expected value.

- **Geometric vs. Arithmetic**: The conflict between positive arithmetic mean (expected value) and negative geometric mean (when betting 100%) explains the counterintuitive result that a game with positive expected value can still be harmful when bet too aggressively.

- **Conservative Betting**: Since the optimal Kelly fraction is negative, any strategy that bets less than 100% (including the 25% modified strategy) moves toward the Kelly-optimal direction, which explains its superior performance characteristics.

**Conclusion:**

The Kelly Criterion reveals that the original strategy (betting 100% of balance) is fundamentally flawed from a long-term growth perspective, despite having positive expected value. The modified strategy's successâ€”evidenced by higher probability of positive outcomes, lower volatility, and better typical (median) resultsâ€”aligns perfectly with Kelly's mathematical framework. The 25% bet strategy, while not necessarily the exact Kelly-optimal fraction, demonstrates the principle that conservative betting can outperform aggressive betting even in games with positive expected value when compounding effects create asymmetric risk-return profiles.


## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing